#include "so_long.h"

/* Notes random
üîµ Si on veut qu'une struct soit MAJ en dehors d'une fonction, il faut obligatoirement passer un pointeur de
üîµ 		cette struct (et v√©rifier que le pointeur est pass√© dans tous les fonctions appelantes en amont)
üü° Callbsack function = Use the amount of parameters mentionned in the .h - If need more, use struct
üü¢ Hooks allow you to add your own functions to the main loop execution of the program, aka these functions get executed every frame.
üü° image->instances[0].x/y = D√©placer une image
üü£ mlx_image_t *img = mlx_new_image(mlx, 32, 32);		= Cr√©er une image √† partir de z√©ro
üü£ mlx_image_t *img = mlx_texture_to_image(mlx, tex);	= Cr√©er une image √† partir d‚Äôune texture existante
üîµ Ne jamais free() ce que MLX a donn√©
üîµ mlx_terminate() s‚Äôoccupe de free tout ce qui vient de MLX
üü† MLX42 ne supporte qu‚Äôun seul mlx_key_hook() √† la fois. ‚úÖ Solution : tout g√©rer dans une seule fonction de hook.
üü† mlx_key_hook() d√©clenche une action quand une touche est press√©e ou rel√¢ch√©e.
üü† mlx_key_hook() appelle ma fonction key_actions (faite sur la base d'une callback function : mlx_keyfun) chaque fois qu‚Äôune touche est press√©e.
‚ÄºÔ∏è MLX42 NB : 2 forbidden functions mlx_put_pixel  and mlx_resize_image

ft_printf("Error\n>> Please invite Diplo to the game !\n");
ft_printf("Error\n>> No friends allowed! Sorry-not-sorry\n");
ft_printf("Error\n>> Corn-Quest cancelled - No way to escape.\n");
ft_printf("Error\n>> Corn-Quest cancelled - Too many escapes.\n");
ft_printf("Error\n>> Corn-Quest cancelled - Nothing to collect !\n\n");

TO DO : Dans check everything, garder copie de game, et transformer les fonctions de v√©rif is_ en booleens
Ensuite, r√©cup√©rer les tiles dans my_game qui sera utilis√© pour le jeu (avec element_position - get_tile_position)
is_ = bool
get_ = r√©cup√©rer un √©l√©ment ou une position
‚ÄºÔ∏è Start with line 121
*/

int		main(int	argc, char **argv)
{
	char *path = PATH_MAP;									// changer pour argv[1] when done

	game	my_game;
	my_game = build_map(path);								// Cr√©ation/Remplissage de la carte et affichage de la fen√™tre de jeu (vide)

	if (!(check_everything(my_game)))						// Attention, on passe my_game donc une copie sera faite = aucune info ne reste
	{
		free_game_content_and_exit("Try again !\n", &my_game);				// ‚ÄºÔ∏è‚ÄºÔ∏è‚ÄºÔ∏è Check if memory leaks
		exit(1);
	}

	display_map(&my_game);												// Set up de l'affichage de la carte (real display dans mlx_loop)

	// Hook = Set up de fonction qui sera appel√©e par mlx_loop
	mlx_key_hook(my_game.window, key_actions, &my_game);					// Seule fonction pour interagir avec le jeu : key_actions
// ------------------------------------------------------------------------- Quit in a clean way when clic on cross. Check if MEM LEAKS ‚ÄºÔ∏è
	mlx_close_hook(my_game.window, clean_and_exit, &my_game);

	mlx_loop(my_game.window);		// ‚ÄºÔ∏èKeep at the end - Starts to render to window with all requested elements, until shutdown is requested

// ----------------------------------------------------------------------------------------------------------------------------------- Clean up ‚úÖ
	//clean_and_exit(stuff_to_free);			// In case ESC pressed or if everything goes correctly and the exit is naturally happening when all collectibles are reached ?
	free_game_content_and_exit("Pass in free_game_content_and_exit function\n", &my_game);
	return(0);
}

// ------------------------------------------------------- Game checklist - Create the required structure to store all the necessary information ‚úÖ
game	build_map(char *path)
{
	game		my_game;											// Solution badass pour passer toutes les infos en meme temps (FAB 4 PRESIDENT)
	char		*line_by_line;										// map[0] me donnait des segfaults donc je procede avec char *
	size_t		length_line;
// ---------------------------------------------------------------------------------------------------------- Edit from .txt to .ber & run tests ‚ÄºÔ∏è
	int size_path = ft_strlen(path);
	char *extension = ft_substr(path, (size_path - 4), size_path);	// üÜì Calloc done pour *extension

	if (ft_strncmp (extension, ft_strdup(".ber"), 5) != 0)			// ‚ÄºÔ∏è Malloc done on strdup mais return non stock√© dans une variable - No need to free ?
		exit (1);

	free(extension);												// ‚úÖ Free

	int	fd;
	fd = open(path, O_RDWR);

	if((!fd) || (fd < 0))
	{
		ft_printf ("Error\n>> Map missing OLALA NICHT GUT\n\n");
		exit (1);
	}
// ----------------------------------------------------------------------------------------- Deal with the map itself first / Get the size of it ‚úÖ
	line_by_line = get_next_line(fd);					// üÜì GNL aloue la memoire a line_by_line
	if (!line_by_line)
	{
		free_gnl_stuff("Error\n>> Map empty or not displayable oO\n", &line_by_line, &fd);	// ‚úÖ Free
	}
	length_line = ft_strlen(line_by_line);
	int line_counter = 0;
	while (line_by_line != NULL)
	{
		free(line_by_line);								// ‚úÖ Free
		line_by_line = get_next_line(fd);				// üÜì GNL aloue la memoire a line_by_line ‚úÖ FREE right above
		line_counter++;
// ------------------------------------------------------------------------------------ Check if all lines are equal in size (= rectangular map) ‚úÖ
		if (((line_by_line != NULL)) && (ft_strlen(line_by_line) != length_line))
		{
			free_gnl_stuff("Error\n>> Sorry, your funky map isn't valid, please make it rectangular !\n", &line_by_line, &fd);	// ‚úÖ Free
		}
	}
	if ((length_line < 4) || (line_counter < 3))	// Taille minimum pour avoir autre chose que des murs
	{
		free_gnl_stuff("Error\n>> Map too small, no space to play :(\n", &line_by_line, &fd);									// ‚úÖ Free
	}
	close(fd);										// Sinon ne lira pas suite
// ---------------------------------------------------------------------------------------------------------------------- Alloc memory & fill it ‚úÖ
	my_game.content = ft_calloc((line_counter + 1), sizeof(char *));	// On alloue les lignes uniquement (colonnes done by GNL) ‚úÖ FREE : In the last loop
	if (!my_game.content)
		exit(1);
	fd = open(PATH_MAP, O_RDWR);
	my_game.content[0] = get_next_line(fd);
	int i = 0;
	while (my_game.content[i] != NULL)
	{
		i++;
		my_game.content[i] = get_next_line(fd);							// Memoire allouee pour chaque ligne ‚úÖ FREE in the loop at the end of the function
	}

	my_game.max_lines = line_counter;
	my_game.max_columns = length_line;

	my_game.escape_position = get_tile_position(my_game, ESCAPE);

	mlx_t	*game_window;
	if(!(game_window = mlx_init(TILE_SIZE*(my_game.max_columns-1), TILE_SIZE*my_game.max_lines, "Space Invader Diplo Corn Quest", false)))	// Connection to the graphical system - MLX MALLOC DONE HERE ‚ÄºÔ∏è
	{
		free_game_content_and_exit("Error in the window allocation\n", &my_game);
		exit(1);
	}
// ‚ÄºÔ∏è‚ÄºÔ∏è‚ÄºÔ∏è Malloc on game_window - Set up mic_mac "stuff to free" struct or use game struct ?
	my_game.window = game_window;

	my_game.player_image = path_to_image(&my_game, my_game.window, PATH_PLAYER);
// ‚ÄºÔ∏è‚ÄºÔ∏è‚ÄºÔ∏è Malloc on player_image - Set up mic_mac "stuff to free" struct or use game struct ?

	return (my_game);
}
