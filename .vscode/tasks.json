{
	"tasks": [
//--------- Tâche 1 : Compilation la plus basique, utile pour compiler et exécuter un seul fichier C sans créer de projet plus complexe ----------------- //
		{
			"type": "cppbuild",
			"label": "C/C++: gcc build active file",		// Attention, tâches aux noms similaires plus bas, ne pas confondre (ici, compilateur gcc)
			"command": "/usr/bin/gcc",						// Utilise gcc pour compiler le fichier C actuellement ouvert (${file})
			"args": [
				"-g",										// Ajoute le flag -g pour inclure des informations de débogage
				"${file}",									// Fichier en cours
				"-o",										// Détermine le nom de l'executable
				"${fileDirname}/${fileBasenameNoExtension}"	// Path de l'exécutable (portant le même nom que le fichier source dans le même dossier)
			],
			"options": {
				"cwd": "${fileDirname}"						// Current Working Directory = Variable qui représente le chemin du dossier où se trouve le fichier actuellement ouvert dans l’éditeur
			},
			"problemMatcher": [
				"$gcc"										//Associe VS Code au détecteur d'erreurs de GCC
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Tâche 2 : Même chose que la précédente, mais avec config légèrement différente -------------------------------------------------------------- //
		{
			"type": "cppbuild",
			"label": "C/C++: cc build active file",		// Attention, tâches aux noms similaires, ne pas confondre (ici, compilateur cc)
			"command": "/usr/bin/cc",					// Utilise cc (un alias pour gcc ou clang) pour compiler le fichier ouvert
			"args": [
				"-g",
				"${file}",
				"-o",
				"${fileDirname}/${fileBasenameNoExtension}",	// Génère un exécutable du nom du fichier, dans le dossier du fichier - ATTENTION, doit matcher "program" dans launch.json
				"-Wall",						// Active tous les avertissements de base
				"-Wextra",						// Active des avertissements supplémentaires
				"-Werror",						// Traite les avertissements comme des erreurs
			],
			"options": {
				"cwd": "${fileDirname}"				// Path du repo où se trouve le fichier à compiler (mentionné plus haut) - ATTENTION - Doit matcher "cwd" dans launch.json
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Tâche 3 : Même chose que les précédentes, mais compilations adaptées à BSD et à certains outils utilisant libbsd ---------------------------- //
		{
			"type": "cppbuild",
			"label": "C/C++: cc build active file bsd",		// Attention, tâches aux noms similaires, ne pas confondre
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"${file}",
				"-o",
				"${workspaceFolder}/a.out",
				"-Wall",
				"-Wextra",
				"-Werror",
				"-DLIBBSD_OVERLAY",							// Ajoute -DLIBBSD_OVERLAY (définit une macro pour BSD)
				"-I/usr/include/bsd",						// Ajoute les headers de la bibliothèque bsd
				"-lbsd",									// Linke la bibliothèque bsd (-lbsd)
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Tâche 4 : Compile et linke LibFt (essentiel pour tester des projets 42) -------------------------------------------------------------------- //
		{
			"type": "cppbuild",						// Tache 5
			"label": "My LibFt library",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"ft_*.c",							// Compile tous les fichiers ft_*.c
				"-o",
				"${workspaceFolder}/a.out",
				// "-Wall",							// Active tous les avertissements de base
				// "-Wextra",						// Active des avertissements supplémentaires
				// "-Werror",						// Traite les avertissements comme des erreurs
				"-DLIBBSD_OVERLAY",
				"-I/usr/include/bsd",				// Ajoute les headers bsd et bibliothèques bsd (idem ligne suivante)
				//"-lbsd",							// -l permet d'inclure une library
				"-I${workspaceFolder}/libft",		// -I = Ajoute un nouveau répertoire à aller scanner pour chercher les include (les .h)
				"-L${workspaceFolder}/libft",		// -L = Ajoute un répertoire à aller scanner pour aller chercher des librairy (.a ou .so)
				//"-lft"							// Liaison avec libft.a (mais la ligne "-lft" est commentée)
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Tâche 5 : Compilation pour Printf (en faire aussi une via Makefile sinon ?) ----------------------------------------------------------------- //
		{
			"type": "cppbuild",
			"label": "C: cc build ft_printf",
			"command": "/usr/bin/cc",		// Utilise cc (un alias pour gcc ou clang) pour compiler le fichier ouvert
			"args": [
				"-g",
				"ft_printf.c", "ft_printf_common_specifiers.c", "ft_printf_hexa_specifiers.c",
				"-o",
				"${workspaceFolder}/a.out",				//Génère un exécutable a.out dans le dossier racine
				"-I${workspaceFolder}/98_include",		// -I = Ajoute un répertoire à aller scanner pour aller chercher des include (.h)
				"-L${workspaceFolder}/99_lib",			// -L = Ajoute un répertoire à aller scanner pour aller chercher des library (.a ou .so) + rajouter lib (ex : "-lft") en dernier arg
				"-lft"							// Liaison avec libft.a (mais la ligne "-lft" est commentée)
				// "-Wall",						// Active tous les avertissements de base
				// "-Wextra",					// Active des avertissements supplémentaires
				// "-Werror",					// Traite les avertissements comme des erreurs
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Tâche 6 : Compilation stricte pour GNL ------------------------------------------------------------------------------- //
		{
			"type": "cppbuild",
			"label": "C/C++: cc build get_next_line",
			"command": "/usr/bin/cc",		// Utilise cc (un alias pour gcc ou clang) pour compiler le fichier ouvert
			"args": [
				"-g",
				"get_next_line.c", "get_next_line_utils.c", "main.c",	// Compile ces fichiers ensemble. (.h pris automatiquement en compte dans le header (include "GNL.h"))
				//line dessous créée pour tester le bonus, décommenter la partie qui m'intéresse
				//"get_next_line_bonus.c", "get_next_line_utils_bonus.c",
				"-D",													// Un argument par quote, donc ici on met -D et BUFFER_SIZE sur 2 lignes differentes
				"BUFFER_SIZE=10",
				//"-DROUQUINETTE_DEBUG", // mis dans fonction instead, sinon main grisee
				"-o",
				"${workspaceFolder}/a.out",								//Génère un exécutable a.out dans le dossier racine
				// "-Wall",												// Active tous les avertissements de base
				// "-Wextra",											// Active des avertissements supplémentaires
				// "-Werror",											// Traite les avertissements comme des erreurs
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Tâche 7 : Compilation stricte pour so_long ------------------------------------------------------------------------------------------------- //
		{
			"type": "cppbuild",
			"label": "C/C++: cc build so_long",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"so_long_main_build.c",		// Fichiers à compiler ensemble (les autres projets sont ajoutés différemment plus bas)
				"so_long_graphics.c",
				"so_long_checkers.c",
				"so_long_path_check.c",
				"so_long_misc.c",
				"so_long_handler_bonus.c",
				"so_long_free_functions.c",
// Sur recommandation de Fab, créé répertoires lib + include qui seront à ajouter dans le .json + makefile de chaque projet, dès que les .h et .a existent
				"-I${workspaceFolder}/98_include",		// -I = Ajoute un répertoire à aller scanner pour aller chercher des include (.h)
				"-I${workspaceFolder}/MLX42/include",	// Idem - Note : MLX42 n'est pas dans le répertoire mentionné ci dessus donc je le rajoute ici

				"-L${workspaceFolder}/99_lib",			// -L = Ajoute un répertoire à aller scanner pour aller chercher des library (.a ou .so) + rajouter lib (ex : "-lft") en dernier arg
				"-L${workspaceFolder}/4_So_Long/",		// Idem - Note : So_Long n'a pas encore de library car WIP, donc je l'ajoute séparément

				//"-DROUQUINETTE_DEBUG",		// Trick super badass si besoin
				"-o",
				"${workspaceFolder}/a.out",		// Génère un exécutable a.out dans le dossier racine (00VSCode)
				// "-Wall",						// Active tous les avertissements de base
				// "-Wextra",					// Active des avertissements supplémentaires
				// "-Werror",					// Traite les avertissements comme des erreurs
				"-lmlx42",						// Commandes necessaires pour utiliser MLX42 (this line + below)
				"-lglfw",						// Goes with mlx42 lib
				"-lgetnextline",				// A chaque nouveau .a/.h, penser à bien ajouter une ligne au dessus de celle-ci. Penser à compiler ce projet avant de tester dans VSCode
				"-lftprintf",
				"-lft"							// -lft = -l ft = -l (lib)ft = Liaison avec libft.a - A METTRE A LA FIN IMPERATIVEMENT Sinon bug de type 'undefined reference to ft_*'
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Tâche 8 : Compilation stricte pour push_swap ----------------------------------------------------------------------------------------------- //
		{
			"type": "cppbuild",
			"label": "C/C++: cc build push_swap",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"push_swap_main.c",
				"push_swap_input_management.c",
				"push_swap_operations.c",
				"push_swap_others.c",
				"push_swap_algorithms.c",
// Sur recommandation de Fab, créé répertoires lib + include qui seront à ajouter dans le .json + makefile de chaque projet, dès que les .h et .a existent
				"-I${workspaceFolder}/98_include",		// -I = Ajoute un répertoire à aller scanner pour aller chercher des include (.h)
				"-L${workspaceFolder}/99_lib",			// -L = Ajoute un répertoire à aller scanner pour aller chercher des library (.a ou .so) + rajouter lib (ex : "-lft") en dernier arg
				"-L${workspaceFolder}/5_Push_Swap/",	// Pour la library du projet en cours
				"-o",
				"${workspaceFolder}/a.out",		// Génère un exécutable a.out dans le dossier racine
				// "-Wall",						// Active tous les avertissements de base
				// "-Wextra",					// Active des avertissements supplémentaires
				// "-Werror",					// Traite les avertissements comme des erreurs
				"-lftprintf",					// A chaque nouveau .a/.h à utiliser, ajouter une ligne au dessus de celle-ci. Penser à compiler le projet avant de tester dans VSCode
				"-lft"							// -lft = -l ft = -l (lib)ft = Liaison avec libft.a - A METTRE A LA FIN IMPERATIVEMENT Sinon bug de type 'undefined reference to ft_*'
			],
			"options": {
				"cwd": "${fileDirname}"
			},
			"problemMatcher": [
				"$gcc"
			],
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"detail": "Task generated by Debugger."
		},
//--------- Tâche 9 : Compil through Makefile pour So-Long -------------------------------------------------------------------------------------------- //
		{
			"label": "Build with Makefile for So_Long",
			"type": "shell",
			"command": "make",
//			"args": [],				// Par défaut, commande make. Ajouter ["fclean"] ou autre si nécessaire
			"args": ["re"],
			"options": {
				"cwd": "${workspaceFolder}/4_So_Long",	// Localisation du Makefile
			},
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"problemMatcher": []
		},
//--------- Tâche 10 : Compil through Makefile pour Push_Swap ------------------------------------------------------------------------------------------ //
		{
			"label": "Build with Makefile for Push_Swap",
			"type": "shell",
			"command": "make",
			"args": ["re"],				// Par défaut, commande make. Ajouter ["re] ou autre si nécessaire
			"options": {
				"cwd": "${workspaceFolder}/5_Push_Swap"		// Localisation du Makefile
			},
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"problemMatcher": []
		},
//--------- Tâche 11 : Compil pour Minitalk Server ----------------------------------------------------------------------------------------------------- //
		{
			"label": "C/C++: cc build minitalk server",
			"type": "shell",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"minitalk_server_main.c",
				"minitalk_binary_conversions_s.c",
				"minitalk_server_actions.c",
				"-I${workspaceFolder}/98_include",
				"-L${workspaceFolder}/99_lib",
				"-L${workspaceFolder}/6_Minitalk/server/server",
				"-o",
				"${workspaceFolder}/6_Minitalk/server/server",
				// "-Wall",						// Active tous les avertissements de base
				// "-Wextra",					// Active des avertissements supplémentaires
				// "-Werror",					// Traite les avertissements comme des erreurs
				"-lftprintf",					// A chaque nouveau .a/.h à utiliser, ajouter une ligne au dessus de celle-ci. Penser à compiler le projet avant de tester dans VSCode
				"-lft"							// -lft = -l ft = -l (lib)ft = Liaison avec libft.a - A METTRE A LA FIN IMPERATIVEMENT Sinon bug de type 'undefined reference to ft_*'
			],
			"options": {
				"cwd": "${workspaceFolder}/6_Minitalk/server"
			},
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"problemMatcher": []
		},
//--------- Tâche 11 : Compil pour Minitalk Client ------------------------------------------------------------------------------------------------------ //
		{
			"label": "C/C++: cc build minitalk client",
			"type": "shell",
			"command": "/usr/bin/cc",
			"args": [
				"-g",
				"minitalk_client_main.c",
				"minitalk_binary_conversions_c.c",
				"-I${workspaceFolder}/98_include",
				"-L${workspaceFolder}/99_lib",
				"-L${workspaceFolder}/6_Minitalk/client/client",
				"-o",
				"${workspaceFolder}/6_Minitalk/client/client",
				// "-Wall",
				// "-Wextra",
				// "-Werror",
				"-lftprintf",
				"-lft"
			],
			"options": {
				"cwd": "${workspaceFolder}/6_Minitalk/client"
			},
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"problemMatcher": []
		},
//--------- Tâche 12 : Tâche tuto (garder en dernier) --------------------------------------------------------------------------------------------------- //
		{
			"label": "C/C++: Tâche",	// Nom de la tâche appelée par la config
			"type": "shell",
			"command": "/usr/bin/cc",
			"args": [
// Flags de compilation puis de linking
				"-g",						// Debug info
				"minitalk_client_main.c",	// Fichier(s) à compiler
// Sur recommandation de Fab, créé répertoires lib + include qui seront à ajouter dans le .json + makefile de chaque projet, dès que les .h et .a existent
				"-I${workspaceFolder}/98_include",	// -I = Ajoute un répertoire à aller scanner pour aller chercher des include (.h)
				"-L${workspaceFolder}/99_lib",		// -L = Ajoute un répertoire à aller scanner pour aller chercher des library (.a ou .so) + rajouter lib (ex : "-lft") en dernier arg
				"-L${workspaceFolder}/***",				// Chemin d'accès du répertoire où se trouve l'exécutable
				//"-DROUQUINETTE_DEBUG",	// Trick super badass si besoin
				"-o",						// Flag qui précède le nom de l'exécutable
				"${workspaceFolder}/***",	// Path + nom de l'exécutable
				"-Wall",					// Active tous les avertissements de base
				"-Wextra",					// Active des avertissements supplémentaires
				"-Werror",					// Traite les avertissements comme des erreurs
// S'assurer que tous les projets/libs ont été compilés avant de les ajouter aux lignes suivantes
				"-lftprintf",				// A chaque nouveau .a/.h à utiliser, ajouter une ligne au dessus de celle-ci.
				"-lft"						// -lft = -l ft = -l (lib)ft = Liaison avec libft.a - A METTRE A LA FIN IMPERATIVEMENT Sinon bug de type 'undefined reference to ft_*'
			],
			"options": {
				"cwd": "${workspaceFolder}/***"	// Path du repo où se trouvent les .c mentionnés plus haut
			},
			"group": {
				"kind": "build",
				"isDefault": true
			},
			"problemMatcher": []
		},
//----------------------------------------------------------------------------------------------------------------------------------------------------- //
],
	"version": "2.0.0"
}

/*Ce fichier tasks.json est utilisé par VS Code pour automatiser la compilation des fichiers C
via des tâches. Il définit plusieurs tâches de compilation qui peuvent être exécutées avant
le lancement du programme (comme défini dans launch.json).
Chaque tâche est une commande shell ou système qui exécute un compilateur (gcc, clang ou cc)
avec différents paramètres.
-----------
Explication des clés principales :
- tasks				Liste des différentes tâches de compilation.
- type				Type de tâche (ex. cppbuild pour la compilation C/C++).
- label				Nom de la tâche, utilisé pour l'exécuter depuis VS Code.
- command			Commande exécutée (ex. /usr/bin/gcc ou clang).
- args				Liste des arguments passés à la commande.
- options.cwd		Répertoire où la commande est exécutée.
- problemMatcher	Permet à VS Code d'afficher les erreurs de compilation.
- group				Définit si la tâche est une tâche de compilation principale.
- detail			Indique que la tâche a été générée automatiquement par le debugger.

VSCode définit ${workspaceFolder} comme la racine du projet ouvert dans VSCode, donc pour moi :
/home/sophie/Documents/00_VS_Code

De la même manière, voici la bonne synthaxe pour désigner le dossier d'un fichier spécifique :
${fileDirname}

*/
