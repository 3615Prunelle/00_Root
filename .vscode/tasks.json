/*Ce fichier tasks.json est utilisé par VS Code pour automatiser la compilation des fichiers C
via des tâches. Il définit plusieurs tâches de compilation qui peuvent être exécutées avant
le lancement du programme (comme défini dans launch.json).
Chaque tâche est une commande shell ou système qui exécute un compilateur (gcc, clang ou cc)
avec différents paramètres.
-----------
Explication des clés principales :
- tasks				Liste des différentes tâches de compilation.
- type				Type de tâche (ex. cppbuild pour la compilation C/C++).
- label				Nom de la tâche, utilisé pour l'exécuter depuis VS Code.
- command			Commande exécutée (ex. /usr/bin/gcc ou clang).
- args				Liste des arguments passés à la commande.
- options.cwd		Répertoire où la commande est exécutée.
- problemMatcher	Permet à VS Code d'afficher les erreurs de compilation.
- group				Définit si la tâche est une tâche de compilation principale.
- detail			Indique que la tâche a été générée automatiquement par le debugger.
*/
{
    "tasks": [
        {
            "type": "cppbuild", //Tache 1
            "label": "C/C++: gcc build active file",
            "command": "/usr/bin/gcc", //Utilise gcc pour compiler le fichier C actuellement ouvert (${file})
            "args": [
                "-fdiagnostics-color=always", //Colorise les diagnostics pour une meilleure lisibilité
                "-g", //Ajoute le flag -g pour inclure des informations de débogage
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}" //Produit un exécutable portant le même nom que le fichier source dans le même dossier
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc" //Associe VS Code au détecteur d'erreurs de GCC
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }, //Sum up : C'est la compilation la plus basique, utile pour compiler et exécuter un seul fichier C sans créer de projet plus complexe
		{
			"label": "build", //Tache 2 - Compilation spécifique pour get_next_line.c
			"command": "clang", //Utilise clang pour compiler, au lieu de gcc
			"args": [
				"get_next_line.c", //Compile uniquement get_next_line.c et get_next_line_utils.c
				"get_next_line_utils.c",
				"-g" //Ajoute -g pour inclure les informations de débogage
			],
			"type": "shell",
			"presentation": {
				"echo": true,
				"reveal": "always",
				"panel": "shared"
			},
			"problemMatcher": {
				"owner": "c",
				"fileLocation": [
					"relative",
					"${workspaceRoot}"
				],
				"pattern": {
					"regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$",
					"file": 1,
					"line": 2,
					"column": 3,
					"severity": 4,
					"message": 5
				}
			} //Personnalise l'affichage des erreurs avec une regex qui capture les erreurs et avertissements
		}, //Sum up : Compilation spécifique pour tester get_next_line sans compiler d'autres fichiers du projet
		{
            "type": "cppbuild", //Tache 3
            "label": "C/C++: cc build active file",
            "command": "/usr/bin/cc", //Utilise cc (un alias pour gcc ou clang) pour compiler le fichier ouvert
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${workspaceFolder}/a.out", //Génère un exécutable a.out dans le dossier du projet
				// "-Wall", //Active tous les avertissements de base
				// "-Wextra", //Active des avertissements supplémentaires
				// "-Werror", //Traite les avertissements comme des erreurs
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }, //SUm up : compilation stricte, utile pour respecter les normes de code propres et éviter les erreurs potentielles.
		{
            "type": "cppbuild", //Tache 4
            "label": "C/C++: cc build active file bsd",
            "command": "/usr/bin/cc",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${workspaceFolder}/a.out",
				"-Wall",
				"-Wextra",
				"-Werror",
				"-DLIBBSD_OVERLAY", //Ajoute -DLIBBSD_OVERLAY (définit une macro pour BSD)
                "-I/usr/include/bsd", //Ajoute les headers de la bibliothèque bsd
                "-lbsd", //Linke la bibliothèque bsd (-lbsd)
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }, //Sum up : Même chose que la précédente, mais compilations adaptées à BSD et à certains outils utilisant libbsd
		{
            "type": "cppbuild", //Tache 5
            "label": "My LibFt library",
            "command": "/usr/bin/cc",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "ft_*.c", //Compile tous les fichiers ft_*.c
                "-o",
                "${workspaceFolder}/a.out",
//				"-Wall",
//				"-Wextra",
//				"-Werror",
				"-DLIBBSD_OVERLAY",
                "-I/usr/include/bsd", //Ajoute les headers et bibliothèques bsd (idem ligne suivante)
                "-lbsd", // -l permet d'inclure une library
				"-I${workspaceFolder}/libft", //Inclut libft
				"-L${workspaceFolder}/libft", //Specifie nouveau repertoire ou il y a une library
				//"-lft" //Liaison avec libft.a (mais la ligne "-lft" est commentée)
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }, //Sum up : Cette tâche compile et linke LibFt, ce qui est essentiel pour tester des projets 42
		{
            "type": "cppbuild", //Tache made w/ Fab pour GNL
            "label": "C/C++: cc build get_next_line",
            "command": "/usr/bin/cc", //Utilise cc (un alias pour gcc ou clang) pour compiler le fichier ouvert
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                //"get_next_line.c", "get_next_line_utils.c", //compile ces 2 fichiers ensemble. Pas besoin de prendre le .h car pris en compte dans le header (include "GNL.h")
                //line dessous créée pour tester le bonus, décommenter la partie qui m'intéresse
				"get_next_line_bonus.c", "get_next_line_utils_bonus.c",
				"-D", //un argument par quote, donc ici on met -D et BUFFER_SIZE sur 2 lignes differentes
				"BUFFER_SIZE=8",
				//"-DROUQUINETTE_DEBUG", // mis dans fonction instead, sinon main grisee
				"-o",
                "${workspaceFolder}/a.out", //Génère un exécutable a.out dans le dossier du projet
				//"-Wall", //Active tous les avertissements de base
				//"-Wextra", //Active des avertissements supplémentaires
				//"-Werror", //Traite les avertissements comme des erreurs
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }, //Sum up : compilation stricte, utile pour respecter les normes de code propres et éviter les erreurs potentielles.
    ],
    "version": "2.0.0"
}
